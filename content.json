{"pages":[{"title":"St.kai","text":"","link":"/about/index.html"}],"posts":[{"title":"Howdy Linu上的&quot;Windows Hello&quot;","text":"我电脑上一直用着简单的数字密码，输入起来比较方便，但是这样太不安全了，于是换成了大小写字母、数字、特殊字符组成的混合密码，但是每次解锁屏幕或者执行需要root权限的命令时输入复杂密码又觉得太过于麻烦，于是想到了Windows Hello,小新PRO13是有红外模块的,可以使用Window Hello,Linux上该如何解决呢？🔍搜索一番发现了一款叫做Howdy,可以使用人脸进行身份验证。 安装1# yay -S howdy 使用前的准备获取设备列表1234567$ v4l2-ctl --list-devicesIntegrated Camera: Integrated C (usb-0000:03:00.4-2): /dev/video0 /dev/video1 /dev/video2 /dev/video3 测试摄像头能否正常使用1$ ffplay /dev/videox 测试之后发现我的只有/dev/video0可以使用。在使用Windows Hello的时候会亮一个红灯但是直接测试/dev/video0并没有亮，可能没有正常打开红外模块。于是我又在Google上搜索了一番，发现了有大佬写过一个启用红外模块的脚本linux-enable-ir-emitter。于是从GayHub上clone下来之后用Gcc编译 编译linux-enable-ir-emitter1$ gcc enable-ir-emitter.c -o enable-ir-emitter 然后报错根据README的指引修改enable-ir-emitter.c，复制config.txt的第二组配置继续编译，成功。 运行编译后的enable-ir-emitter1$ .\\enable-ir-emitter 这时候用ffplay测试，发现/dev/video2已经可以正常开启红外发射器了。 开机加载enable-ir-emitter脚本每此开机的时候总不能都手动解锁然后运行脚本吧，这样就失去了此次折腾的意义。配置systemd服务让它开机自动加载。 复制编译后的文件到/usr/loacl/bin1# cp enable-ir-emitter /usr/local/bin 复制enable-ir-emitter.service到/etc/systemd/system/1# cp enable-ir-emitter.service /etc/systemd/system/ 启用服务1# systemctl enable enable-ir-emitter 这样就可以在开机的时候自动加载脚本了 查看摄像头的支持格式12345678$ v4l2-ctl -d DEVICE_PATH --list-formats-extioctl: VIDIOC_ENUM_FMT Type: Video Capture [0]: 'GREY' (8-bit Greyscale) Size: Discrete 640x360 Interval: Discrete 0.067s (15.000 fps) Interval: Discrete 0.033s (30.000 fps) 配置PAM配置将下面的信息加入到所有需要人脸解锁PAM配置文件中，sudo和GDM的屏幕解锁我用的比较多所以在/etc/pam.d/sudo和/etc/pam.d/system-local-login配置了howdy认证 1auth sufficient pam_python.so /lib/security/howdy/pam.py 配置Howdy1# howdy config 默认使用nano编辑器打开，我使用vim编辑器，需要在命令前加上EDITOR环境变量 1# EDITOR=vim howdy config 配置摄像头路径1device_path = /dev/video2 设置黑暗阈值dark_threshold = 90 添加人脸模型1# howdy add 测试1# sudo -i 这时候Howdy已经可以正常调用红外摄像头了 其它使用几次后发现每次调用Howdy的时候终端都会出现警告，根据ArchWiki的提示，这是opencv的警告，可以将opencv的日志级别降低 1export OPENCV_LOG_LEVEL=ERROR 将上面的代码加入到.zshrc(zsh用户)或者.bashrc(bash用户)每次调用Howdy认证的时候终端就不会有警告了。 参考 Howdy Howdy - ArchWiki linux-enable-ir-emitter","link":"/2021/01/26/Howdy-Linu%E4%B8%8A%E7%9A%84-Windows-Hello/"},{"title":"uGet调用aria2实现极速下载","text":"我在Linux上一直使用uGet作为下载器下载文件，但是感觉下载速度不如aria2，于是想用上aria2插件。 首先安装aria2、uGet 1# pacman -S aria2 uget 安装uget-integrator插件 1# yay -S uget-integrator 安装浏览器对应的链接工具Chrome 1# yay -S uget-integrator-chrome` Firefox 1# yay -S uget-integrator-firefox 浏览器安装下载插件 uGet IntegrationChromeFirefox uGet Edit–&gt;Settings–&gt;Plug-in 选择 aria2Arguments 输入--enable-rpc=true --rpc-allow-origin-all -D --disable-ipv6 --check-certificate=false 重启Uget 便可以调用aria2","link":"/2020/03/07/uGet%E8%B0%83%E7%94%A8aria2%E5%AE%9E%E7%8E%B0%E6%9E%81%E9%80%9F%E4%B8%8B%E8%BD%BD/"},{"title":"unzip解决中文路径乱码问题","text":"unzip解压从Windos拷贝过来的文件时经常出现乱码，这是因为Linux上unzip默认UTF-8编码，而Windows简体中文版用zip软件压缩时文件名一般会使用GBK编码，这就导致了乱码。知道问题了那Google搜一搜怎么解决吧，Google告诉我用-O选项，然而unzip并没有-O选项啊，那哪来的-O呢？原来大神给unzip打了转码补丁unzip-iconv，但是unzip自打2009年以来一直没有更新过，iconv也就一直没有进入mainline,所以我们需要用unzip的包含iconv补丁的版本,aur已经有人打了包unzip-iconv,所以直接安装就可以,aur上的这个版本不仅包含了转码补丁，还包含一些其漏洞的补丁。 1# yay -S unzip-iconv cn仓库上也有这个包 1# pacman -S unzip-iconv 这个时候我们就可以使用-O选项了 1$ unzip -O [iconv] file[.zip] [-d exdir] e.h.: unzip -O GBK file.zip","link":"/2020/03/16/unzip%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"JavaScript中的赋值、浅拷贝和深拷贝","text":"前两天用对Vue做了一个页面，内用是表格，点击表格的编辑按钮弹出模态框可以进行编辑。 操作 姓名 性别 出生日期 身份证号 data 编辑 张三 男 1970-01-01 01234567 data[0] 编辑 李四 男 1980-01-01 12345670 data[1] 编辑 王五 女 1990-01-01 23456701 data[2] 点击编辑后弹出模态框将data[0]赋值给person 1let person = data[0] person 姓名 张三 性别 男 出生日期 1970-01-01 身份证号 0123457 编辑后弹窗的内容发现表格上的内容也会同步改变，难道是法外狂徒在捣鬼？ 首先让我们回顾一下JavaScript的数据类型 JavaScript的数据类型JavaScrit中共有7种基本数据类型（原始数据类型）和对象 基本类型 Undefined Null Boolean String Symbol Numeric Number BigInt 对象类型 Object Funcion Date JSON Array Map …… JavaScript中所有的基本类型只能替换，不能改变。 Assignment赋值1234567891011121314151617let x = 3;let y = x;y + 1;console.log(x);console.log(y);// expected output: 3// expected output: 4let data = [{ name: 'zhangsan', sex: 1 }];let person = data[0];person.name = 'wangwu';console.log(data[0]);// expected output: { name: 'wangwu', sex: 1 } 这是因为虽然data[0]和person的名称不同，但是却指向了同一个内存地址。 变量 内存地址 内存空间 data[0]person &rarr;&rarr; 0x11FF00 &rarr; { name: ‘wangwu’, sex: 1 } data和person既不是相同的变量名也不是相同的数据类型，但是data[0]和person他们指向了相同的内存地址，所以改变person时，data[0]也会同步改变。那如何只改变person而不改变data[0]呢？我们把两个data[0]复制一份给person让他们存储在不同的内存块中不就可以了，这就是拷贝。拷贝分为浅拷贝和深拷贝。 浅拷贝(Shallow Copy)浅拷贝是指将对象内的原始数据类型复制一份，引用类型复制内存地址。我们新建一个对象 1let obj1 = {srt:'str' , arr:[1,2,3]} 拷贝前 obj 内存区域A 内存区域B obj1.str &rarr; ‘str’ obj1.arr &rarr; 0x11FF00 &rarr; [1,2,3] 将obj1浅拷贝之到obj2之后 obj 内存区域A 内存区域B obj1.str &rarr; ‘str’ obj1.arr &rarr; 0x11FF00 &rarr; [1,2,3] obj2.str &rarr; ‘str’ obj2.str &rarr; 0x11FF00 ↗ 浅拷贝的方式1.Oject.assign()Object.assign()可以将一个或多个源对象拷贝给目标对象并返回目标对象语法 1Object.assign(target, sources) 2.展开语法(Spread syntax) 对象拷贝 1let objClone = { ...obj }; 数组拷贝 1let newArr = [...oldArr]; 3.数组分割Array.prototype.slice()1let newArray = oldArray.slice([begin[, end]]) 4. 数组合并Array.prototype.concat()1let newArray = oldArray.concat([value1[, ...[, valueN]]]) 等同于 1let newArray = [...oldArray, ...value1, ...] 数组的分割和合并首先会创建一个新的数组，所以也就对原来的数组完成了拷贝。 深拷贝(Deep Copy)深拷贝将是将原来的对象递归赋值，首先创建一个新的对象，然后将原来对象的内容递归复制到新的对象，原对象的引用类型也会复制一份。 1. JSON.parse(JSON.stringify(object))1let newObj = JSON.parse(JSON.stringify(oldObj)) 缺点: undefinde、function、symbol 在序列化过程中会被忽略 Date在序列化过程中会被转为字符串（调用了toJSON()) NaN 和 Infinity 格式的数值及 null 都会被当做 null 循环引用的对象会形成无限循环然后报错 2. Node.js利用v8引擎的序列化和反序列化接口12const v8 = require('v8');let newObj = v8.deserialize(v8.serialize(oldObj)) 3.第三方JS库 Lodash 1lodash.clonedeep(objects) AngularJS 1angular.copy(source, [destination]) jQuery 1jQuery.extend( true, target, object1 [, objectN ] ) 参考 JavaScript data types and data structures | MDN ECMA-262 Spread syntax (…) | MDN What is the most efficient way to deep clone an object in JavaScript? - Stack Overflow","link":"/2021/02/01/JavaScript%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"uGet","slug":"uGet","link":"/tags/uGet/"},{"name":"Downloader","slug":"Downloader","link":"/tags/Downloader/"},{"name":"unzip","slug":"unzip","link":"/tags/unzip/"},{"name":"Mojibake","slug":"Mojibake","link":"/tags/Mojibake/"},{"name":"Howdy","slug":"Howdy","link":"/tags/Howdy/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Copy","slug":"Copy","link":"/tags/Copy/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"unzip","slug":"Linux/unzip","link":"/categories/Linux/unzip/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Howdy","slug":"Linux/Howdy","link":"/categories/Linux/Howdy/"}]}